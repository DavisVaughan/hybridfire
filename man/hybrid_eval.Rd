% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hybrid-eval.R
\name{hybrid_eval}
\alias{hybrid_eval}
\title{Evaluate an expression with hybrid evaluation}
\usage{
hybrid_eval(expr, mask = list(), env = caller_env())
}
\arguments{
\item{expr}{An expression to evaluate.}

\item{mask}{A named list. The names match the columns in the data frame. A single
element of this list is also a list, corresponding to the chunks for
that particular column.}

\item{env}{The environment where \code{expr} was specified.}
}
\description{
\code{hybrid_eval()} iterates through the AST of \code{expr}, evaluating each
component in a way that is convenient for mixing hybrid eval with standard
eval.
}
\details{
\itemize{
\item If \code{expr} a call, we extract out the function with \code{node_car()}, and
the arguments with \code{node_cdr()}.
\itemize{
\item The \code{fn} is really a name at this point, so we evaluate it in the
\code{env} to get the real function back.
\item The \code{args} are mapped over, and \code{hybrid_eval()} is called on each one.
\item We then use \code{hybrid_replace()} to check if we can replace the standard
\code{fn} with a hybrid version. i.e. can we replace \code{mean(x)} with
\code{grouped_mean(x)}?
\item If the function gets replaced (or \code{grouped_mean()} was supplied
directly), it is considered "hybridizable". A hybridizable function
like \code{grouped_mean(x)} expects \code{x} as a list of chunks, so we can
just call it directly. Otherwise we have standard eval and we
\code{pmap()} over all the args, calling \code{fn} on each group.
}
}
}
